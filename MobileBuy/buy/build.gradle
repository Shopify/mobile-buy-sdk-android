buildscript {
    dependencies {
        classpath 'me.tatarka:gradle-retrolambda:3.5.0'
    }
}

apply plugin: 'com.android.library'
apply plugin: 'maven'
apply plugin: 'com.github.dcendents.android-maven'
apply plugin: 'com.jfrog.bintray'
apply plugin: 'maven-publish'
apply plugin: 'me.tatarka.retrolambda'

android {
    compileSdkVersion rootProject.ext.compileSdkVersion
    buildToolsVersion rootProject.ext.buildToolsVersion
    com.android.ddmlib.DdmPreferences.setTimeOut(60000) // https://code.google.com/p/android/issues/detail?id=104305

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    defaultConfig {
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionName VERSION_NAME
        version VERSION_NAME

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        debug {
            buildConfigField 'okhttp3.logging.HttpLoggingInterceptor.Level', 'OKHTTP_LOG_LEVEL', 'okhttp3.logging.HttpLoggingInterceptor.Level.BODY'

            // We pull the shop settings either from the Environment or a file called shop.properties at the root of the project.
            // Environment variables will take precedence, we will attempt to read those first.
            def shopDomain
            def apiKey
            def appId
            def useMockResponses
            def androidPayPublicKey
            def runTestCoverage

            // get the shop setting from the environment if there any
            shopDomain = System.getenv("SHOP_DOMAIN")
            apiKey = System.getenv("API_KEY")
            appId = System.getenv("APP_ID")
            androidPayPublicKey = System.getenv("ANDROID_PAY_PUBLIC_KEY")

            runTestCoverage = System.getProperty("RunTestCoverage")

            // pull the store properties from the local file if it exists.  Environment variables take precedence
            def shopProperties = new Properties();
            File shopPropertiesFile = project.file('shop.properties')

            if (shopPropertiesFile.exists()) {
                shopProperties.load(new FileInputStream(shopPropertiesFile))
                shopDomain = shopDomain ?: shopProperties["SHOP_DOMAIN"]
                apiKey = apiKey ?: shopProperties["API_KEY"]
                appId = appId ?: shopProperties["APP_ID"]
                androidPayPublicKey = androidPayPublicKey ?: shopProperties["ANDROID_PAY_PUBLIC_KEY"]
            }

            if (!shopDomain) {
                shopDomain = ""
            }
            if (!apiKey) {
                apiKey = ""
            }
            if (!appId) {
                appId = ""
            }
            if (!androidPayPublicKey) {
                androidPayPublicKey = ""
            }
            if (!runTestCoverage) {
                runTestCoverage = "false"
            }

            buildConfigField "String", "SHOP_DOMAIN", "\"" + shopDomain.toString() + "\""
            buildConfigField "String", "API_KEY", "\"" + apiKey.toString() + "\""
            buildConfigField "String", "APP_ID", "\"" + appId.toString() + "\""
            buildConfigField "String", "ANDROID_PAY_PUBLIC_KEY", "\"" + androidPayPublicKey.toString() + "\""

            testCoverageEnabled runTestCoverage.toBoolean()
        }

        release {
            minifyEnabled = false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            buildConfigField 'okhttp3.logging.HttpLoggingInterceptor.Level', 'OKHTTP_LOG_LEVEL', 'okhttp3.logging.HttpLoggingInterceptor.Level.NONE'
        }
    }

    libraryVariants.all { variant ->
        variant.outputs.each { output ->
            def outputFile = output.outputFile
            if (outputFile != null && outputFile.name.endsWith('.aar')) {
                def fileName = "${archivesBaseName}-${VERSION_NAME}.aar"
                output.outputFile = new File(outputFile.parent, fileName)
            }
        }

        if (variant.name.equals('release')) {

            task("javadoc", type: Javadoc, dependsOn: assembleRelease) {
                description "Generate Javadoc"
                title = "Mobile Buy SDK"
                source = android.sourceSets.main.java.srcDirs

                def androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
                classpath = files(variant.javaCompile.classpath.files) + files(androidJar)

                options {
                    linksOffline("http://d.android.com/reference", "${android.sdkDirectory}/docs/reference")
                    links("http://square.github.io/retrofit/2.x/retrofit/")
                }

                exclude('**/customTabs/**')
                exclude('**/BuildConfig.java')
            }

            task("javadocJar", type: Jar, dependsOn: javadoc) {
                description "Bundles Javadoc into zip"
                classifier = "javadoc"
                baseName = 'buy'
                from tasks["javadoc"]
            }

            artifacts {
                archives project.javadocJar
            }

            task("archiveReleasePackage", type: Zip, dependsOn: [javadocJar]) {
                baseName = "mobile-buy-sdk-android"

                from("./build/libs") {
                    include javadocJar.getArchiveName()
                }

                from("./build/docs") {
                    include 'javadoc/**'
                }

                from("./build/outputs/aar") {
                    include "buy-" + VERSION_NAME + ".aar"
                }

                from("../..") {
                    include "LICENSE"
                    include "NOTICE"
                }

                into(baseName + "-" + VERSION_NAME)
            }
        }
    }

    sourceSets { main { assets.srcDirs = ['src/main/assets'] } }

    lintOptions {
        abortOnError false
        disable 'APISchema'
    }
}

dependencies {
    compile dep.okhttp
    compile dep.okhttpLogging
    compile dep.androidSupportAnnotations
    compile dep.playServicesWallet
    compile dep.shopifyGraphqlSupport
    compile dep.jodaTime

    androidTestCompile 'org.mockito:mockito-core:1.9.5'
    androidTestCompile 'com.google.dexmaker:dexmaker:1.1'
    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.1'
    androidTestCompile 'com.android.support.test:runner:0.5'
    androidTestCompile 'com.android.support.test:rules:0.5'
}

/*
Great guide for publishing to JCenter:
http://inthecheesefactory.com/blog/how-to-upload-library-to-jcenter-maven-central-as-dependency/en

Also search for 'userOrg' here (we need this to publish to the Shopify organization on Bintray):
https://github.com/bintray/gradle-bintray-plugin

Steps:
gradlew install
gradlew bintrayUpload
*/
install {
    repositories.mavenInstaller {
        // This generates POM.xml with proper parameters
        pom {
            project {
                packaging POM_PACKAGING
                groupId POM_GROUP_ID
                artifactId POM_ARTIFACT_ID

                // Add your description here
                name POM_NAME
                description POM_DESCRIPTION
                url POM_WEB_URL

                // Set your license
                licenses {
                    license {
                        name POM_LICENSE
                        url POM_LICENSE_URL
                    }
                }

                scm {
                    connection POM_DEVELOPER_URL
                    developerConnection POM_DEVELOPER_URL
                    url POM_WEB_URL
                }
            }
        }
    }
}

task sourcesJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    classifier = 'sources'
}

artifacts {
    archives sourcesJar
}

File localProperties = project.rootProject.file('local.properties')
Properties properties = new Properties()
if (localProperties.exists()) {
    properties.load(localProperties.newDataInputStream())
}

bintray {
    user = properties.getProperty("bintray.user")
    key = properties.getProperty("bintray.apikey")

    configurations = ['archives']
    pkg {
        userOrg = POM_DEVELOPER_NAME
        repo = POM_REPO
        name = POM_NAME
        desc = POM_DESCRIPTION
        websiteUrl = POM_WEB_URL
        vcsUrl = POM_DEVELOPER_URL
        licenses = [POM_LICENSE]
        publish = true
        publicDownloadNumbers = true
        version {
            desc = POM_DESCRIPTION
        }
    }
}

task updateSchema(type: DefaultTask, group: "GraphQL", description: "Download GraphQL store front API schema and run generation script") {
    doLast {
        println("Updating GraphQL API schema...")
        def scriptFilePath = project.file('update_schema.rb').absolutePath
        def targetFilePath = project.projectDir.absolutePath + '/src/main/java/com/shopify/buy3/APISchema.java'
        def scriptCommand = "${scriptFilePath} -t ${targetFilePath}"
        println("Running script: " + scriptCommand)
        def scriptProc = scriptCommand.execute()
        scriptProc.in.eachLine {line -> println line}
        scriptProc.err.eachLine {line -> println 'ERROR: ' + line}
        if (scriptProc.waitFor() != 0) {
            throw new GradleException('Failed to update API schema')
        }
        println("API schema has been updated!")
    }
}
